<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Memory Graph</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; z-index: 1; }
  </style>
</head>
<body>
<div id="info">Click a node to see details</div>
<script async src="https://unpkg.com/es-module-shims@1.4.0/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.178.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.178.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>
<script type="module">

import * as THREE from 'https://unpkg.com/three@0.178.0/build/three.module.js';

import { OrbitControls } from 'https://unpkg.com/three@0.178.0/examples/jsm/controls/OrbitControls.js';
import { VRButton } from 'https://unpkg.com/three@0.178.0/examples/jsm/webxr/VRButton.js';
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101015);
// simple holodeck-style grid for orientation
const grid = new THREE.GridHelper(10, 20, 0x4444ff, 0x4444ff);
grid.position.y = -0.01;
scene.add(grid);
const room = new THREE.Mesh(
  new THREE.BoxGeometry(10, 10, 10),
  new THREE.MeshBasicMaterial({ color: 0x080808, side: THREE.BackSide })
);
scene.add(room);
const ambient = new THREE.AmbientLight(0x888888);
scene.add(ambient);
const dir = new THREE.DirectionalLight(0xffffff, 0.5);
dir.position.set(1, 3, 2);
scene.add(dir);
// raise all nodes to this height so they appear level with the viewer
const Y_OFFSET = 1.6;
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
// place the user at typical eye height so the origin is in front
camera.position.set(0, 1.6, 3);
const controls = new OrbitControls(camera, renderer.domElement);

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
const info = document.getElementById('info');

function onPointer(event) {
  pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
  pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(scene.children);
  if (intersects.length) {
    const node = intersects[0].object.userData.node;
    if (node) info.textContent = node.how;
  }
}
window.addEventListener('pointerdown', onPointer);

fetch('/memory_graph.json')
  .then(r => r.json())
  .then(data => {
    const colors = {};
    const spheres = {};
    data.forEach(n => {
      if (!(n.cluster in colors)) {
        colors[n.cluster] = new THREE.Color(Math.random(), Math.random(), Math.random());
      }
      const geom = new THREE.SphereGeometry(0.02);
      const mat = new THREE.MeshBasicMaterial({ color: colors[n.cluster] });
      const mesh = new THREE.Mesh(geom, mat);
      // offset nodes so the current moment sits in front of the user
      mesh.position.set(n.pos[0], n.pos[1] + Y_OFFSET, n.pos[2]);
      mesh.userData.node = n;
      scene.add(mesh);
      spheres[n.uuid] = mesh;
    });
    data.forEach(n => {
      n.edges.forEach(e => {
        const a = spheres[n.uuid];
        const b = spheres[e.to];
        if (!a || !b) return;
        const geom = new THREE.BufferGeometry().setFromPoints([a.position, b.position]);
        const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
        const line = new THREE.Line(geom, mat);
        scene.add(line);
      });
    });
  });

function animate() {
  renderer.setAnimationLoop(() => {
    controls.update();
    renderer.render(scene, camera);
  });
}
animate();
</script>
</body>
</html>
